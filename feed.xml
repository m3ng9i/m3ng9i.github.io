<?xml version="1.0" encoding="utf-8"?>
 
<feed xmlns="http://www.w3.org/2005/Atom">
 
    <title>My Candy</title>
    <author><name>m3ng9i</name></author>
    <id>http://mengqi.info/feed.xml</id>
    <link ref="self" href="http://mengqi.info/feed.xml"/>
    <link rel="alternate" href="http://mengqi.info"/>
    <updated>2015-08-21T16:50:11+08:00</updated>

    <entry><title>Go：使用 ResponseRecorder 记录 HTTP 响应报文</title>
<author><name>m3ng9i</name></author>
<id>http://mengqi.info/html/2015/201508211700-record-http-response-in-go.html</id>
<link rel="alternate" href="http://mengqi.info/html/2015/201508211700-record-http-response-in-go.html"/>
<published>2015-08-21T17:00:00+08:00</published>
<updated>2015-08-21T17:00:00+08:00</updated>
<content type="html">
    &lt;p&gt;Go 的 &lt;a href=&quot;https://golang.org/pkg/net/http/&quot; rel=&quot;nofollow&quot;&gt;net/http&lt;/a&gt; 包提供了丰富的 API 用来创建 HTTP 服务。在创建自己的 HTTP 服务时，通常会建立一个 &lt;a href=&quot;https://golang.org/pkg/net/http/#Handler&quot; rel=&quot;nofollow&quot;&gt;Handler&lt;/a&gt; 来处理请求，并将响应内容写入到 &lt;a href=&quot;https://golang.org/pkg/net/http/#ResponseWriter&quot; rel=&quot;nofollow&quot;&gt;http.ResponseWriter&lt;/a&gt; 中。&lt;/p&gt;

&lt;p&gt;下面的代码是一个简单的例子：将当前工作目录作为根目录，利用 http 包的 &lt;a href=&quot;https://golang.org/pkg/net/http/#FileServer&quot; rel=&quot;nofollow&quot;&gt;FileServer Handler&lt;/a&gt; 创建了一个静态文件服务器，接受 HTTP 请求并做出响应，最后输出日志。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import &amp;#34;os&amp;#34;
import &amp;#34;net/http&amp;#34;
import &amp;#34;fmt&amp;#34;

type Server struct {
    Root string
}

func (this *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // 创建一个静态文件服务器
    http.FileServer(http.Dir(this.Root)).ServeHTTP(w, r)

    // 输出日志
    fmt.Println(r.URL.Path)
}

func main() {
    root, err := os.Getwd()
    if err != nil {
        fmt.Fprintf(os.Stderr, err.Error())
        os.Exit(1)
    }
    server := &amp;amp;Server{Root:root}
    http.ListenAndServe(&amp;#34;:8080&amp;#34;, server)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中，主要的工作由 &lt;code&gt;http.FileServer&lt;/code&gt; 完成，HTTP 服务运行的细节被封装到这个函数内部了，对我们是不可见的。例如完成一个响应后，HTTP 状态码是什么，是 200、404 还是 304，FileServer 并没有提供给我们。如果你想要知道有多少比特被发送到了客户端，也比较困难，虽然可以通过 &lt;code&gt;ResponseWriter.Header()&lt;/code&gt; 来探测头信息中 Content-Length 的值，但当请求的是一个目录时，FileServer 是不会发送 Content-Length 的 （在 Go 1.4 下测试），这时也无法得知发送的字节数。&lt;/p&gt;

&lt;p&gt;Go 的 &lt;a href=&quot;https://golang.org/pkg/net/http/httptest/&quot; rel=&quot;nofollow&quot;&gt;net/http/httptest&lt;/a&gt; 包提供了一个 &lt;code&gt;ResponseRecorder&lt;/code&gt; 可以将原本要发送到客户端的响应报文截获并记录下来，我们可以从中提取到需要的信息。得到所需信息后，我们再将现场还原，把 HTTP 报文头、报文体写入到 ResponseWriter，这样客户端就可以正常收到响应结果。&lt;/p&gt;

&lt;p&gt;下面就是一个使用 ResponseRecorder 的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import &amp;#34;os&amp;#34;
import &amp;#34;net/http&amp;#34;
import &amp;#34;net/http/httptest&amp;#34;
import &amp;#34;fmt&amp;#34;

type Server struct {
    Root string
}

func (this *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {

    // 创建一个 recorder 用来保存响应信息
    recorder := httptest.NewRecorder()

    // 将静态文件服务器的响应信息截获并记录到 recorder 中，这时客户端是没有输出的
    http.FileServer(http.Dir(this.Root)).ServeHTTP(recorder, r)

    // 从 recorder 中提取记录下来的 Response Header，设置为 ResponseWriter 的 Header
    for key, value := range recorder.HeaderMap {
        for _, val := range value {
            w.Header().Set(key, val)
        }
    }

    // 提取 recorder 中记录的状态码，写入到 ResponseWriter 中
    w.WriteHeader(recorder.Code)

    var contentLength int
    if recorder.Body != nil {
        // 将 recorder 记录的 Response Body 写入到 ResponseWriter 中，客户端收到响应报文体
        w.Write(recorder.Body.Bytes())

        // 计算 Response Body 的大小（即 Content-Length）
        contentLength = recorder.Body.Len()
    }

    // 将状态码，请求路径，Content-Length 作为日志输出
    fmt.Printf(&amp;#34;%d %s, %d\n&amp;#34;, recorder.Code, r.URL.Path, contentLength)

}

func main() {
    root, err := os.Getwd()
    if err != nil {
        fmt.Fprintf(os.Stderr, err.Error())
        os.Exit(1)
    }
    server := &amp;amp;Server{Root:root}
    http.ListenAndServe(&amp;#34;:8080&amp;#34;, server)
}
&lt;/code&gt;&lt;/pre&gt;

        
</content>
</entry><entry><title>Golang 中的 UTF-8 与 GBK 编码转换</title>
<author><name>m3ng9i</name></author>
<id>http://mengqi.info/html/2015/201507071345-using-golang-to-convert-text-between-gbk-and-utf-8.html</id>
<link rel="alternate" href="http://mengqi.info/html/2015/201507071345-using-golang-to-convert-text-between-gbk-and-utf-8.html"/>
<published>2015-07-07T13:45:00+08:00</published>
<updated>2015-07-07T13:45:00+08:00</updated>
<content type="html">
    &lt;p&gt;在 Golang 中转换 UTF-8 与 GBK 编码的文本，可以使用 Go 官方的 &lt;a href=&quot;https://godoc.org/golang.org/x/text&quot; rel=&quot;nofollow&quot;&gt;golang.org/x/text&lt;/a&gt; 包实现，这个包可以通过下面的命令安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;go get golang.org/x/text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果访问 golang.org 站点存在困难，也可以使用下面的命令通过 github 下载 text 包的代码，下载完成后，再手工将其移动至 &lt;code&gt;$GOPATH/src/golang.org/x/text&lt;/code&gt; 目录中完成安装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git clone --depth 1 https://github.com/golang/text.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面就是 UTF-8 与 GBK 编码转换的例子代码。这里创建了两个函数：&lt;code&gt;GbkToUtf8()&lt;/code&gt; 和 &lt;code&gt;Utf8ToGbk()&lt;/code&gt;，分别进行 GBK 到 UTF-8 和 UTF-8 到 GBK 的转换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
    &amp;#34;bytes&amp;#34;
    &amp;#34;golang.org/x/text/encoding/simplifiedchinese&amp;#34;
    &amp;#34;golang.org/x/text/transform&amp;#34;
    &amp;#34;io/ioutil&amp;#34;
    &amp;#34;fmt&amp;#34;
)

func GbkToUtf8(s []byte) ([]byte, error) {
    reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewDecoder())
    d, e := ioutil.ReadAll(reader)
    if e != nil {
        return nil, e
    }
    return d, nil
}

func Utf8ToGbk(s []byte) ([]byte, error) {
    reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewEncoder())
    d, e := ioutil.ReadAll(reader)
    if e != nil {
        return nil, e
    }
    return d, nil
}

func main() {

    s := &amp;#34;GBK 与 UTF-8 编码转换测试&amp;#34;
    gbk, err := Utf8ToGbk([]byte(s))
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(string(gbk))
    }

    utf8, err := GbkToUtf8(gbk)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(string(utf8))
    }
}
&lt;/code&gt;&lt;/pre&gt;

        
</content>
</entry><entry><title>使用 Golang 通过 Proxy 抓取网页</title>
<author><name>m3ng9i</name></author>
<id>http://mengqi.info/html/2015/201506062329-socks5-proxy-client-in-golang.html</id>
<link rel="alternate" href="http://mengqi.info/html/2015/201506062329-socks5-proxy-client-in-golang.html"/>
<published>2015-06-06T23:29:00+08:00</published>
<updated>2015-06-06T23:29:00+08:00</updated>
<content type="html">
    &lt;p&gt;使用 Go 自带的 &lt;code&gt;http&lt;/code&gt; 包可以很方便的抓取网页，例如下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import &amp;#34;fmt&amp;#34;
import &amp;#34;net/http&amp;#34;
import &amp;#34;io/ioutil&amp;#34;

func main() {
    resp, err := http.Get(&amp;#34;http://mengqi.info&amp;#34;)
    if err != nil {
        fmt.Println(err)
    } else {

        b, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil {
            fmt.Println(err)
        } else {
            fmt.Println(string(b))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果想要通过代理服务器抓取网页该怎么办呢？我们可以尝试下 &lt;a href=&quot;https://godoc.org/golang.org/x/net/proxy&quot; rel=&quot;nofollow&quot;&gt;golang.org/x/net/proxy&lt;/a&gt; 这个包。由于这个包并不在 Go 的标准库中，需要使用 &lt;code&gt;go get&lt;/code&gt; 命令进行安装。&lt;/p&gt;

&lt;p&gt;下面是利用 proxy 包创建 socks5 proxy client 并抓取网页的例子。&lt;/p&gt;

&lt;p&gt;首先需要创建一个 &lt;em&gt;dialer&lt;/em&gt;，它包含了 sock5 代理服务器的地址、用户名、密码。&lt;a href=&quot;http://golang.org/pkg/net/#Dialer&quot; rel=&quot;nofollow&quot;&gt;net 包文档&lt;/a&gt;提到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A Dialer contains options for connecting to an address.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是创建 dialer 的代码，这里假设代理服务器的 IP 为 127.0.0.1，端口为 8080，用户名为 username, 密码为 password：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;dialer, err := proxy.SOCKS5(&amp;#34;tcp&amp;#34;, &amp;#34;127.0.0.1:8080&amp;#34;,
    &amp;amp;proxy.Auth{User:&amp;#34;username&amp;#34;, Password:&amp;#34;password&amp;#34;},
    &amp;amp;net.Dialer {
        Timeout: 30 * time.Second,
        KeepAlive: 30 * time.Second,
    },
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果代理服务器并不需要用户名、密码，可以将 proxy.SOCKS5 函数的第三个参数设置为 &lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;接下来需要创建一个 &lt;em&gt;transport&lt;/em&gt;，它会利用刚才创建的 dialer 进行 TCP 连接。&lt;a href=&quot;http://golang.org/pkg/net/http/#pkg-overview&quot; rel=&quot;nofollow&quot;&gt;net/http 包文档&lt;/a&gt;提到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创建 transport 的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;transport := &amp;amp;http.Transport{
    Proxy: nil,
    Dial: dialer.Dial,
    TLSHandshakeTimeout: 10 * time.Second,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，创建一个 &lt;em&gt;http client&lt;/em&gt;，它会用到刚才创建的 transport：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;client := &amp;amp;http.Client { Transport: transport }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了 http client，就可以通过代理服务器发起 http 请求了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;response, err := client.Get(&amp;#34;http://mengqi.info&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是完整的例子代码，client 的创建过程被封装成了一个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import &amp;#34;fmt&amp;#34;
import &amp;#34;net&amp;#34;
import &amp;#34;time&amp;#34;
import &amp;#34;os&amp;#34;
import &amp;#34;net/http&amp;#34;
import &amp;#34;io/ioutil&amp;#34;
import &amp;#34;golang.org/x/net/proxy&amp;#34;


func Socks5Client(addr string, auth ...*proxy.Auth) (client *http.Client, err error) {

    dialer, err := proxy.SOCKS5(&amp;#34;tcp&amp;#34;, addr,
        nil,
        &amp;amp;net.Dialer {
            Timeout: 30 * time.Second,
            KeepAlive: 30 * time.Second,
        },
    )
    if err != nil {
        return
    }

    transport := &amp;amp;http.Transport{
        Proxy: nil,
        Dial: dialer.Dial,
        TLSHandshakeTimeout: 10 * time.Second,
    }

    client = &amp;amp;http.Client { Transport: transport }

    return
}


func main() {

    client, err := Socks5Client(&amp;#34;127.0.0.1:8080&amp;#34;)
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }

    // ip138 可以显示请求客户端的 IP
    resp, err := client.Get(&amp;#34;http://1111.ip138.com/ic.asp&amp;#34;)
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }

    b, err := ioutil.ReadAll(resp.Body)
    resp.Body.Close()
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(string(b))
    }

}
&lt;/code&gt;&lt;/pre&gt;

        
</content>
</entry><entry><title>在 Go 语言中获取字符串中的字符个数</title>
<author><name>m3ng9i</name></author>
<id>http://mengqi.info/html/2015/201506012300-using-golang-to-count-the-number-of-characters.html</id>
<link rel="alternate" href="http://mengqi.info/html/2015/201506012300-using-golang-to-count-the-number-of-characters.html"/>
<published>2015-06-01T23:00:00+08:00</published>
<updated>2015-06-01T23:00:00+08:00</updated>
<content type="html">
    &lt;p&gt;在 Go 语言中，是不能用 &lt;code&gt;len&lt;/code&gt; 函数来统计字符串中的字符个数的，这是因为在 Go 中，字符串是以 UTF-8 为格式进行存储的，在字符串上调用 len 函数，取得的是字符串包含的 byte 的个数。&lt;/p&gt;

&lt;p&gt;例如字符串：&lt;code&gt;Hello, 世界&lt;/code&gt; 包含 9 个字符。使用 &lt;code&gt;len(&amp;#34;Hello, 世界&amp;#34;)&lt;/code&gt; 得到的结果为 &lt;code&gt;13&lt;/code&gt;，因为这个字符串占用 13 个字节：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;s := &amp;#34;Hello, 世界&amp;#34;
fmt.Println(len(s)) // 13
fmt.Println([]byte(s)) // [72 101 108 108 111 44 32 228 184 150 231 149 140]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么如何统计 Golang 字符串中的字符个数呢？有下面几种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;bytes.Count()&lt;/code&gt; 统计&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;strings.Count()&lt;/code&gt; 统计&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;将字符串转换为 &lt;code&gt;[]rune&lt;/code&gt; 后调用 len 函数进行统计&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;utf8.RuneCountInString()&lt;/code&gt; 统计&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package count

import &amp;#34;bytes&amp;#34;
import &amp;#34;strings&amp;#34;
import &amp;#34;unicode/utf8&amp;#34;

func f1(s string) int {
    return bytes.Count([]byte(s), nil) - 1
}

func f2(s string) int {
    return strings.Count(s, &amp;#34;&amp;#34;) - 1
}

func f3(s string) int {
    return len([]rune(s))
}

func f4(s string) int {
    return utf8.RuneCountInString(s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用上面 4 个函数计算字符串 &lt;code&gt;Hello, 世界&lt;/code&gt; 都会得到正确的字符个数：9。那究竟哪个方法更好一些呢？做一下测试看看：&lt;/p&gt;

&lt;p&gt;创建文件：&lt;code&gt;count_test.go&lt;/code&gt;，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package count

import &amp;#34;bytes&amp;#34;
import &amp;#34;strings&amp;#34;
import &amp;#34;unicode/utf8&amp;#34;
import &amp;#34;testing&amp;#34;

func f1(s string) int {
    return bytes.Count([]byte(s), nil) - 1
}

func f2(s string) int {
    return strings.Count(s, &amp;#34;&amp;#34;) - 1
}

func f3(s string) int {
    return len([]rune(s))
}

func f4(s string) int {
    return utf8.RuneCountInString(s)
}

var s = &amp;#34;Hello, 世界&amp;#34;

func Benchmark1(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        f1(s)
    }
}

func Benchmark2(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        f2(s)
    }
}

func Benchmark3(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        f3(s)
    }
}

func Benchmark4(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        f4(s)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在命令行中运行命令：&lt;code&gt;go test count_test.go -bench &amp;#34;.*&amp;#34;&lt;/code&gt;，输出如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;testing: warning: no tests to run
PASS
Benchmark1	20000000	       109 ns/op
Benchmark2	20000000	        61.6 ns/op
Benchmark3	10000000	       220 ns/op
Benchmark4	30000000	        58.1 ns/op
ok  	command-line-arguments	7.843s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看来，速度最快的是 &lt;code&gt;utf8.RuneCountInString()&lt;/code&gt;。&lt;/p&gt;

        
</content>
</entry><entry><title>RSS 阅读器 QReader 发布</title>
<author><name>m3ng9i</name></author>
<id>http://mengqi.info/html/2015/201505271335-qreader.html</id>
<link rel="alternate" href="http://mengqi.info/html/2015/201505271335-qreader.html"/>
<published>2015-05-27T13:35:00+08:00</published>
<updated>2015-05-27T13:35:00+08:00</updated>
<content type="html">
    &lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/qreader_on_phone.jpg&quot; alt=&quot;QReader&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最近用 Go 语言和 JavaScript 写了一个 RSS 阅读器 &lt;a href=&quot;https://github.com/m3ng9i/qreader&quot; rel=&quot;nofollow&quot;&gt;QReader&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;主要功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按照标签分类 feed&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;为每个 feed 单独设置更新周期&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;设置最大已读保留数，当某个 feed 的未读文章数量超过设定的值后，较早的未读文章会被自动标记为已读&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;设置最大文章保留数，当某个 feed 的已读文章数量超过设定的值后，较早的已读文章会被自动删除&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;可以按随机顺序显示抓取的文章条目&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;设置每页显示的条目数量&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;文章加星&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;设置登录密码&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;与 QReader 服务器通讯的数据可以开启 TLS 加密&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;支持使用 Socks5 代理服务器抓取 feed&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行 QReader 需要你用一台 PC 做 server，程序运行后，使用电脑或手机上的浏览器访问。&lt;/p&gt;

&lt;p&gt;这个项目我学到的一些东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com&quot; rel=&quot;nofollow&quot;&gt;Git&lt;/a&gt;：优秀的版本管理软件&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/go-xorm/xorm&quot; rel=&quot;nofollow&quot;&gt;Xorm&lt;/a&gt;：强大的 ORM 库&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://angularjs.org&quot; rel=&quot;nofollow&quot;&gt;AngularJS&lt;/a&gt;：路由和模板很好用&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.rssboard.org/rss-specification&quot; rel=&quot;nofollow&quot;&gt;RSS&lt;/a&gt; 和 &lt;a href=&quot;http://tools.ietf.org/html/rfc4287&quot; rel=&quot;nofollow&quot;&gt;Atom&lt;/a&gt; 规范：根据规范我写了 &lt;a href=&quot;https://github.com/m3ng9i/feedreader&quot; rel=&quot;nofollow&quot;&gt;feedreader&lt;/a&gt; 包来做 feed 解析&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看 &lt;a href=&quot;https://github.com/m3ng9i/qreader&quot; rel=&quot;nofollow&quot;&gt;QReader 截图与更多说明&lt;/a&gt;，&lt;a href=&quot;https://github.com/m3ng9i/qreader/releases&quot; rel=&quot;nofollow&quot;&gt;下载 QReader&lt;/a&gt;。欢迎使用，如果你喜欢，请给我一个 star。&lt;/p&gt;

        
</content>
</entry><entry><title>编译时向 go 程序写入 git 版本信息</title>
<author><name>m3ng9i</name></author>
<id>http://mengqi.info/html/2015/201502171941-build-go-program-with-git-version.html</id>
<link rel="alternate" href="http://mengqi.info/html/2015/201502171941-build-go-program-with-git-version.html"/>
<published>2015-02-17T19:41:00+08:00</published>
<updated>2015-02-17T19:41:00+08:00</updated>
<content type="html">
    &lt;p&gt;如何在 &lt;a href=&quot;https://golang.org&quot; title=&quot;点击前往 golang 官方网站&quot; rel=&quot;nofollow&quot;&gt;go&lt;/a&gt; 程序中记录版本信息？最简单的办法就是手工输入。下面是一个例子。&lt;/p&gt;

&lt;p&gt;程序 &lt;code&gt;myproject.go&lt;/code&gt; 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import &amp;#34;fmt&amp;#34;
import &amp;#34;flag&amp;#34;

var _version_ = &amp;#34;v0.1&amp;#34;

func main() {
    var version bool
    flag.BoolVar(&amp;amp;version, &amp;#34;v&amp;#34;, false, &amp;#34;-v&amp;#34;)
    flag.Parse()

    if version {
        fmt.Printf(&amp;#34;Version: %s&amp;#34;, _version_)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;版本信息被保存到变量 &lt;code&gt;_version_&lt;/code&gt; 中，当程序编译后，生成可执行文件 myproject。在命令行运行 &lt;code&gt;./myproject -v&lt;/code&gt; 后，显示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;Version: v0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这么做并没有什么不妥，但如果你的程序经常进行更新，那么频繁的修改 _version_ 变量的值会显得非常繁琐。&lt;/p&gt;

&lt;h1&gt;go build&lt;/h1&gt;

&lt;p&gt;go 程序的编译命令 &lt;code&gt;go build&lt;/code&gt; 包含一个 &lt;code&gt;-ldflags&lt;/code&gt; 选项，可以向链接器传递指令。向链接器传一个 &lt;code&gt;-X&lt;/code&gt; 指令可以设置程序中字符串变量的值。利用这个方法能够实现在编译时设置程序的版本信息。对于上面的那个 go 程序，使用下面的编译命令可以将 main 包中的 _version_ 变量的值设置为 v0.2：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;go build -ldflags &amp;#34;-X main._version_ &amp;#39;v0.2&amp;#39;&amp;#34;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译后，运行 &lt;code&gt;./myproject -v&lt;/code&gt; 将显示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;Version: v0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要同时设置多个变量，可以参照以下格式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;go build -ldflags &amp;#34;-X importpath.name value -X importpath_2.name_2 value_2 ...&amp;#34;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们从 go 程序中离开一下，看一下 git。&lt;/p&gt;

&lt;h1&gt;git&lt;/h1&gt;

&lt;p&gt;在使用 &lt;a href=&quot;http://git-scm.com&quot; title=&quot;点击前往 git 官方网站&quot; rel=&quot;nofollow&quot;&gt;git&lt;/a&gt; 作为程序开发的版本控制软件时，每向 git 做一次提交，都会生成一个 sha1 格式的 commit id。由于每一个 commit id 都不相同，这样我们就可以把 commit id 作为程序的特征值，在编译程序时，将其写入到程序中。&lt;/p&gt;

&lt;p&gt;下图是在 &lt;a href=&quot;http://sourcetreeapp.com&quot; rel=&quot;nofollow&quot;&gt;SourceTree&lt;/a&gt; 中查看 git log 的截图。可以看到，除了 commit id，git 日志还可以包含分支名称、标签等信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/build_go_program_with_git_version_1.png&quot; alt=&quot;git 日志&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上信息可以通过 git 命令提取出来。&lt;/p&gt;

&lt;p&gt;下面的命令可以提取出最近一条 git 日志的 commit id：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git log --pretty=format:&amp;#34;%h&amp;#34; -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的命令可以提取出当前的 git 分支名称：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git rev-parse --abbrev-ref HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的命令可以提取出最近一个标签的名称，如果当前分支没有创建过标签则会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git describe --abbrev=0 --tags
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;构造 go 编译程序&lt;/h1&gt;

&lt;p&gt;为了进行演示，我修改了上面的 go 程序，加入了分支名称、commit id、编译时间 3 个变量。修改后的 &lt;code&gt;myproject.go&lt;/code&gt; 代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import &amp;#34;fmt&amp;#34;
import &amp;#34;flag&amp;#34;

var _version_   = &amp;#34;&amp;#34;
var _branch_    = &amp;#34;&amp;#34;
var _commitId_  = &amp;#34;&amp;#34;
var _buildTime_ = &amp;#34;&amp;#34;

func main() {
    var version bool
    flag.BoolVar(&amp;amp;version, &amp;#34;v&amp;#34;, false, &amp;#34;-v&amp;#34;)
    flag.Parse()

    if version {
        fmt.Printf(&amp;#34;Version: %s, Branch: %s, Build: %s, Build time: %s\n&amp;#34;,
            _version_, _branch_, _commitId_, _buildTime_)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了实现自动化的提取 git 日志信息并将其编译进 go 程序，我用 &lt;a href=&quot;http://python.org&quot; rel=&quot;nofollow&quot;&gt;python&lt;/a&gt; 写了一个脚本程序 &lt;code&gt;build.py&lt;/code&gt; 来完成这个任务。这个程序会调用上述的若干 git 命令，将提取到的信息拼装为一个 go build 命令，然后运行此命令完成编译。&lt;/p&gt;

&lt;p&gt;完整的 &lt;code&gt;build.py&lt;/code&gt; 代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env python3

import os, time, subprocess

def runCmd(cmd):
    p = subprocess.Popen(cmd, shell = True, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    stdout = p.communicate()[0].decode(&amp;#39;utf-8&amp;#39;).strip()
    return stdout

# Get last tag.
def lastTag():
    return runCmd(&amp;#39;git describe --abbrev=0 --tags&amp;#39;)

# Get current branch name.
def branch():
    return runCmd(&amp;#39;git rev-parse --abbrev-ref HEAD&amp;#39;)

# Get last git commit id.
def lastCommitId():
    return runCmd(&amp;#39;git log --pretty=format:&amp;#34;%h&amp;#34; -1&amp;#39;)

# Assemble build command.
def buildCmd():
    buildFlag = []

    version = lastTag()
    if version != &amp;#34;&amp;#34;:
        buildFlag.append(&amp;#34;-X main._version_ &amp;#39;{}&amp;#39;&amp;#34;.format(version))

    branchName = branch()        
    if branchName != &amp;#34;&amp;#34;:
        buildFlag.append(&amp;#34;-X main._branch_ &amp;#39;{}&amp;#39;&amp;#34;.format(branchName))

    commitId = lastCommitId()
    if commitId != &amp;#34;&amp;#34;:
        buildFlag.append(&amp;#34;-X main._commitId_ &amp;#39;{}&amp;#39;&amp;#34;.format(commitId))

    # current time
    buildFlag.append(&amp;#34;-X main._buildTime_ &amp;#39;{}&amp;#39;&amp;#34;.format(time.strftime(&amp;#34;%Y-%m-%d %H:%M %z&amp;#34;)))

    return &amp;#39;go build -ldflags &amp;#34;{}&amp;#34;&amp;#39;.format(&amp;#34; &amp;#34;.join(buildFlag))

if subprocess.call(buildCmd(), shell = True) == 0:
    print(&amp;#34;build finished.&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行 &lt;code&gt;./build.py&lt;/code&gt; 对 go 程序进行编译。编译完成后，再运行编译好的程序：&lt;code&gt;./myproject -v&lt;/code&gt;。可以看到，标签：&lt;code&gt;v1.0&lt;/code&gt;、分支名称：&lt;code&gt;master&lt;/code&gt;、commit id：&lt;code&gt;e5b593c&lt;/code&gt; 以及编译时间都被写入到了 go 程序中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Version: v1.0, Branch: master, Build: e5b593c, Build time: 2015-02-17 15:46 +0800
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是很方便？&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hyper-carrot/go_command_tutorial&quot; rel=&quot;nofollow&quot;&gt;go command tutorial&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://golang.org/cmd/go/&quot; rel=&quot;nofollow&quot;&gt;Command go&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://golang.org/cmd/ld/&quot; rel=&quot;nofollow&quot;&gt;Command ld&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git-scm.com/doc&quot; rel=&quot;nofollow&quot;&gt;Git Documentation&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;

        
</content>
</entry><entry><title>使用命令行分析日志文件</title>
<author><name>m3ng9i</name></author>
<id>http://mengqi.info/html/2015/201502142232-text-data-analysis.html</id>
<link rel="alternate" href="http://mengqi.info/html/2015/201502142232-text-data-analysis.html"/>
<published>2015-02-14T22:32:00+08:00</published>
<updated>2015-02-14T22:32:00+08:00</updated>
<content type="html">
    &lt;p&gt;文本文件是一种结构简单，被广泛使用的文件类型。通常我们可以使用操作系统自带的软件查看文本文件的内容，但是对于包含大量数据的日志文件，如果要查看和提取其中的信息，使用普通的编辑器往往无法达到一个好的效果。当文件过大时，普通的编辑器可能会无法打开或者反应变慢。在一个大的日志文件中查找数据时，使用图形界面的编辑器进行操作会显得十分繁琐。这种情况下，使用命令行来观察和分析文件就是一种方便和有效的方法。&lt;/p&gt;

&lt;p&gt;如果你使用的是 Linux/Mac，那么本文介绍的命令都可以直接在操作系统的命令行界面中使用。如果你使用的是 Windows ，可以安装一个叫做 &lt;a href=&quot;http://www.cygwin.com&quot; rel=&quot;nofollow&quot;&gt;Cygwin&lt;/a&gt; 的软件，为 Windows 带来一个类似 Unix 的命令行运行环境。&lt;/p&gt;

&lt;p&gt;本文假设你对基本的命令行操作有所了解，例如知道如何打开命令行程序窗口、可以查看和切换目录等。&lt;/p&gt;

&lt;p&gt;以下示例使用了一个文件名为 example.log 的文件，内容包括时间、地区、用来表示订单号和金额的数字。这些数据使用程序随机生成，各字段由制表符分隔。你可以 &lt;a href=&quot;http://mengqi.info/static/2015/text_data_analysis_example.log&quot;&gt;点此&lt;/a&gt; 下载这个文件。&lt;/p&gt;

&lt;h1&gt;查看文件概况&lt;/h1&gt;

&lt;p&gt;使用 &lt;code&gt;cat&lt;/code&gt; 命令可以查看文件的完整内容，如果要查看 example.log 的内容，可以输入以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_01.png&quot; alt=&quot;cat命令&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当命令输入完毕并回车后，文件的内容便显示在了命令行界面的窗口中。如果文件的内容很多，就会在窗口中不断的滚动直到将文件内容都输出完毕，如果你要尽早结束输出，可以按下 &lt;code&gt;CTRL+C&lt;/code&gt; 键停止 cat 命令的输出。&lt;/p&gt;

&lt;p&gt;你可以在输出的结果中为每一行内容添加编号，只需要给 cat 命令添加一个 &lt;code&gt;-n&lt;/code&gt; 参数即可实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat -n example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_02.png&quot; alt=&quot;使用cat命令显示行号&quot;/&gt;&lt;/p&gt;

&lt;p&gt;另一个查看文件内容的命令是 &lt;code&gt;more&lt;/code&gt; ，举例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;more example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于超过一屏内容的文件，在输出一屏后， more 会自动暂停。暂停后，你可以按&lt;em&gt;回车键&lt;/em&gt;输出下一行内容，按&lt;em&gt;空格键&lt;/em&gt;输出下一屏内容，按 &lt;em&gt;q&lt;/em&gt; 退出。运行效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_03.gif&quot; alt=&quot;more命令&quot;/&gt;&lt;/p&gt;

&lt;p&gt;另外两个比较实用的命令是 &lt;code&gt;head&lt;/code&gt; 和 &lt;code&gt;tail&lt;/code&gt; ，它们分别可以输出文件的前 10 行或后 10 行。在观察比较大的文件结构时，这两个命令非常有用。举例：&lt;/p&gt;

&lt;p&gt;输出前 10 行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;head example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出后 10 行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;tail example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在 head 或 tail 命令后面加上参数： &lt;code&gt;-数字&lt;/code&gt; 自定义输出的行数，举例：&lt;/p&gt;

&lt;p&gt;输出前 3 行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;head -3 example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出后 5 行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;tail -5 example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要统计一个文件的行数，可以使用 &lt;code&gt;wc&lt;/code&gt; 命令，举例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;wc -l example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wc 命令的 &lt;code&gt;-l&lt;/code&gt; 参数的含义是：只输出文件的行数。如果不加这个参数，那么会同时统计文件的行数、单词数和字节。这个命令可以很方便的让我们了解文件的规模。下图可以看出，example.log 文件共有 1000 行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_04.png&quot; alt=&quot;wc命令&quot;/&gt;&lt;/p&gt;

&lt;p&gt;也可以使用通配符显示多个文件的行数。例如，&lt;code&gt;wc -l *.log&lt;/code&gt; 命令会统计当前目录下每个扩展名为 log 的文件的行数，同时此命令也会统计这些文件的总行数。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_05.png&quot; alt=&quot;wc命令显示多个文件的行数&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果你要统计一个文件的字符数，可以使用 &lt;code&gt;-m&lt;/code&gt; 参数。在你写完一篇纯文本格式的文章后，这个命令可以很方便的进行字数统计。举例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;wc -m example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;在文件中查询信息&lt;/h1&gt;

&lt;p&gt;使用 &lt;code&gt;grep&lt;/code&gt; 命令可以将文件中包含特定文字的行抽取出来。例如，&lt;code&gt;grep 河北 example.log&lt;/code&gt; 命令会扫描整个文件，如某一行包含「河北」则会显示这一行内容：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_06.png&quot; alt=&quot;grep命令&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;grep -v&lt;/code&gt; 命令可以将包含特定文字的行排除。例如，运行命令 &lt;code&gt;grep -v 山西 example.log&lt;/code&gt; 后会输出所有不包含「山西」的行。&lt;/p&gt;

&lt;p&gt;你也可以使用正则表达式进行更复杂的信息提取。命令 &lt;code&gt;grep -E &amp;#34;北京|上海&amp;#34; example.log&lt;/code&gt; 会提取出包含「北京」或「上海」的行，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_07.png&quot; alt=&quot;grep命令-正则表达式&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;抽取部分数据&lt;/h1&gt;

&lt;p&gt;使用 &lt;code&gt;cut&lt;/code&gt; 命令可以很方便的从文本文件中抽取部分数据。例如，抽取第 1 和第 3 列数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cut -f 1,3 example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_08.png&quot; alt=&quot;cut命令&quot;/&gt;&lt;/p&gt;

&lt;p&gt;cut 命令的 &lt;code&gt;-f&lt;/code&gt; 参数表示提取若干字段的数据，后面的 &lt;code&gt;1,3&lt;/code&gt; 表示需要的字段序号。如果需要提取 2 至 4 字段，除了使用 &lt;code&gt;-f 2,3,4&lt;/code&gt; 参数，也可以用 &lt;code&gt;-f 2-4&lt;/code&gt; 来表示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cut -f 2-4 example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 cut 命令，制表符为默认的字段分隔符。如果要将其它字符设置为字段分隔符，则需要使用 &lt;code&gt;-d&lt;/code&gt; 参数，举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cut -d : -f 2 example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上例将字段分隔符设置为冒号，并提取出第 2 个字段的数据，也就是时间字段中的「分钟」那一列。运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_09.png&quot; alt=&quot;cut命令，设置字段分隔符&quot;/&gt;&lt;/p&gt;

&lt;p&gt;除了按字段提取数据，也可以按字符来提取，这时要用到 &lt;code&gt;-c&lt;/code&gt; 参数。举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cut -c 6-16 example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上命令提取出第 6 至 16 个字符，也就是日志中的月、日、时、分的部分。运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_10.png&quot; alt=&quot;cut命令，按字符提取&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;排序&lt;/h1&gt;

&lt;p&gt;example.log 日志内容并不是按照时间排序的，如果需要排序后的结果，可以使用 &lt;code&gt;sort&lt;/code&gt; 命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sort example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 example.log 的时间字段正好在第一列的位置，因此上面的命令运行结束后便自动按时间字段排好顺序：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_11.png&quot; alt=&quot;sort命令&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果要根据其他字段排序，可以使用 &lt;code&gt;-k&lt;/code&gt; 参数，下例会根据 example.log 文件的第 3 个字段排序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sort -k 3 example.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_12.png&quot; alt=&quot;sort命令-k参数&quot;/&gt;&lt;/p&gt;

&lt;p&gt;sort 还有其它几个参数十分常用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;-t  指定字段分隔符（配合 -k 参数使用）
-r  逆序排序
-R  随机排序（Mac OS X 不支持此参数） 
-u  去掉重复的行
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;使用管道组合多个命令&lt;/h1&gt;

&lt;p&gt;Linux/Unix 命令行强大的地方就是可以利用管道连接多个命令。管道符为 &lt;code&gt;|&lt;/code&gt; ，你可以这样使用管道：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;命令1 | 命令2 | 命令3 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;管道符左边的命令产生的输出将会作为管道符右边命令的输入。上例中「命令1」的运行结果变成了「命令2」的原始数据，「命令2」将「命令1」输出的运行结果处理完毕后，传送给了「命令3」，「命令3」将「命令2」运行的结果处理完毕后，如果还有下一个命令，则将运行结果继续传递给下一个命令使用，否则就将运行结果显示在命令行窗口中。&lt;/p&gt;

&lt;p&gt;管道符就像串糖葫芦一样，将多个命令串了起来。我们可以根据自己的需要，利用管道符将多个命令组合起来，完成更复杂的数据处理工作。下面是几个例子：&lt;/p&gt;

&lt;p&gt;根据某个字段出现的次数进行统计：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cut -f 2 example.log | sort | uniq -c | sort
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子提取出 example.log 中的「地区」字段（由 &lt;code&gt;cut -f 2 example.log&lt;/code&gt; 命令实现），统计其在整个文件中出现的次数（由 &lt;code&gt;uniq -c&lt;/code&gt; 命令实现），并按照从少到多进行排序（由第二个 &lt;code&gt;sort&lt;/code&gt; 命令实现）。提供给 &lt;code&gt;uniq -c&lt;/code&gt; 命令的数据必须是已排序的数据，否则将会得出错误的运行结果，因此在 &lt;code&gt;uniq -c&lt;/code&gt; 前面还有一个 &lt;code&gt;sort&lt;/code&gt; 命令。运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_13.png&quot; alt=&quot;管道1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;计算 example.log 文件中，地区为「北京」的订单的平均金额：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;grep 北京 example.log | cut -f 4 | awk &amp;#39;BEGIN{sum=0}{sum+=$0}END{print sum/NR}&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子取出包含「北京」的行（由 &lt;code&gt;grep 北京 example.log&lt;/code&gt; 命令实现），然后取出金额字段（由 &lt;code&gt;cut -f 4&lt;/code&gt; 命令实现），最后将所有金额相加，并除以日志条数计算出订单平均金额（由 &lt;code&gt;awk &amp;#39;BEGIN{sum=0}{sum+=$0}END{print sum/NR}&amp;#39;&lt;/code&gt; 命令实现）。运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_14.png&quot; alt=&quot;管道2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;统计 example.log 文件中包含多少个地区：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cut -f 2 example.log | sort -u | wc -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上例先用 &lt;code&gt;cut -f 2&lt;/code&gt; 抽取出包含「地区」信息的字段，然后使用 &lt;code&gt;sort -u&lt;/code&gt; 进行剔重（去除重复数据），最后用 &lt;code&gt;wc -l&lt;/code&gt; 来统计数据个数。运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_15.png&quot; alt=&quot;管道3&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;将运行结果保存到文件中&lt;/h1&gt;

&lt;p&gt;前面的例子都将运行结果直接输出到命令行窗口，如果想要将运行结果保存到文件中，可以使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 将输出重定向到一个文件中。例如，下例根据日期统计订单数量，最后使用 &lt;code&gt;&amp;gt; new.log&lt;/code&gt; 将最终结果保存到 new.log 文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cut -d &amp;#34; &amp;#34; -f 1 example.log | sort | uniq -c &amp;gt; new.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在命令运行完毕后，我们还可以使用 cat 命令来查看这个新生成的文件的内容，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mengqi.info/static/2015/text_data_analysis_16.png&quot; alt=&quot;重定向到文件&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;获取帮助&lt;/h1&gt;

&lt;p&gt;以上介绍的部分命令可以使用 &lt;code&gt;-h&lt;/code&gt;、&lt;code&gt;--help&lt;/code&gt; 参数获取帮助信息，如果要查看详细的使用手册，可以使用 &lt;code&gt;man 命令名称&lt;/code&gt; 来查阅。举例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;man grep
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;阅读推荐&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://linux.vbird.org/&quot; rel=&quot;nofollow&quot;&gt;鸟哥的linux私房菜&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;

        
</content>
</entry>
</feed>
